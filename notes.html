<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>CS 4323 Compiler</title>
	<meta name='Generator' content='Zim 0.68'>
	<style type='text/css'>
		a          { text-decoration: none      }
		a:hover    { text-decoration: underline }
		a:active   { text-decoration: underline }
		strike     { color: grey                }
		u          { text-decoration: none;
					 background-color: yellow   }
		tt         { color: #2e3436;            }
		pre        { color: #2e3436;
					 margin-left: 20px          }
		h1         { text-decoration: underline;
					 color: #4e9a06; margin-bottom: 0 }
		h2         { color: #4e9a06; margin-bottom: 0 }
		h3         { color: #4e9a06; margin-bottom: 0 }
		h4         { color: #4e9a06; margin-bottom: 0 }
		h5         { color: #4e9a06; margin-bottom: 0 }
		p          { margin-top: 0              }
		span.zim-tag {
			color: #ce5c00;
		}
		div.zim-object {
			border-style:solid;
			border-width:1px;
		}
		.checked-box {list-style-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAANOgAADMQBiN+4gQAAAAd0SU1FB9gKGQ8sMEGsKGkAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAEBUlEQVRIx62V22tdRRTGf7Nn73P2ybntnNOe3NqkPTGgLTVUUZF6QatSLOKTPgqCIqLgQ0H/A1sQQbBYCBb1QfAxiC8tSO1FqHkwJVKtjdTGNraUmObsc9nXmfGh7cGYpM1D5nHWzPetteZb3wg2eB2YqYm4zSadsMtoboiNBH/3TE0awx6j+MRoxoTg/IYRvP19TQrJS0bzhdHGSyKFkLTtjSKwMjyiEz43ynhtP6bdjBCWyFobAf7eT7VhNF/q1FRbjYjmUohlCVPwnB+6FUxMTJipqSmUUhhjEGKd3bMT4ks/Y6oLBK2Yth8hHYtCJXOix7Nf7xLMzc0xOzvLzp078TyPNE3viW3QJPXzhNWbxFFKHCmMhoLn/FHodd48vGfhapdAacXQlkFK5dL6wIUm6fuTZPuvqDQhaMUYYyiVyuQr6rXDexYuAdi3tSv1ZJNs/R/CaszzT+1na88uXFnCEnJVgivBNN8uTJKmHQI/ptOOcXNZzMz9mOqFs90OHpipWcYwlo5P4ebnuOkrvr5wgrH+h3im7y36MzuwRXYZeKha/OhP0EkadFoxQSdGSotedR/+XwMc2XvKdNUFOFqZx6LKZWIiwjgkikNmLp/hm8sH+K1zjFTHXfBYdTi+eJArzXM0GxFxoBDCopLvo/fqEwi1XPkWkGqjFo2TgB1jOYZUKZTS/D1/ncmLh7jon0IbRWoiTi59ymzzJEEQE3cStNZsGxqlfPE57MBbOR8fP3hDGalOO9fq2DlBvmZw8xa2IxACGn6TydlD/O6f5OzSV/zif0cYhLQaEXGkKBbz7Ov/AOlXV1cxgBJRI3fuSTrpTawt18kWIZN1CFuaONI0w0WOXfsI43YIggh/KUSlhqxrMz74AkOZcWBm9QkH+Gw8NDLuITi+m0yzhluSyJzBLcpblUhFxywSRAEtPwQjsKVN30CNh0uvYuOubSHLtN3J0TO1j0pmBNuFbFWRK0gyPRZpktL2I5JQkclKakNlnh54g6ocvevUr/Ai2a7wineEkcJupA3S1Wg0nVZM2E6wbEF5U5G9Q++wI7sfR7h3N8HVNstykBfzH+KJEZwiWD0aIwxCgJ0R1Mu7GXOeJSuK93bZtQIle4D9pUNU5DC5jEsu55AvZakM5NicGyEj8uuz8bUCQgj67QfY671P3vEoeC69gy695U1U7NG7XV0pUwBjDJa1/JJlWWxzHuflzQe5FJ/GsgUVuZ2t8lEkTvfc0aNHb72flBhjVicQQqCUuvM3/M+WDVguWBrMVdDXEGZlBVEUrVCU9d9s5+fnaTQa2PZyPxEIhJaI1EEoZwX4ncynp6fXrmB4eJjR0VFarRbNZnP9P9rt9gohqNVq1Ov1ZbF/AZGev3hLJ2/zAAAAAElFTkSuQmCC)}
		.xchecked-box {list-style-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAANOgAADMQBiN+4gQAAAAd0SU1FB9gKGQ8bDYnDxEwAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAEK0lEQVRIx9WVS2hTWRjHf/eR3CY1nbxMH2YiZRQS6qO13YlMVxY3SnVcuNIBFezGpSADLoQqLu1sHJCqdCFSXFpw4YOCSH3BtFqttTNamabX3DS5bfO6uffMoglja3RGcDMHzuac7/z/53++//cd+L8P6VuCPQYZ8ADNgBd4J31DcDcQs+GnHByRocEDv0kfBSjAOlYCs11Q+gpwDegS8LMJ+3QIK0ATzEhV8Odnz5bzw8P4dJ25aJQ/WlvJ1df/K7hSLtOcTNI+Pk69rpMTgqIQhCDvh1/VSpw79+gRrRMTmLZNezLJJsPg+a5dmOEwQlFqg1sWG16/Jv7sGWXDwBACFQjC9HcwIMONKkGp4PGAJGEDS0IQmZlhnWnye3c3eiyGo6qr3WHbrJ+dJf7gAXI6zSIr72T7/fgzmT4FHnTBsgrQBfYvTU0km5vxz86iADnAm0rRPTWFt7cXZccOJJcLAGHb2K9ekT93jmwmwwdAAFpjI6Ntbfxw5879ag7l6o1sr5eHHR3IsRgeQK/M4sQE+YEB7JcvEY6zAj45SWFgAPPxYwzHoQxIkQjTPT0kIxE+Noj8sexFn4/xnh58iQTeSpHkHAdrbIzi0BCOrmNPTpK/eJHM3bt8sCyKQCiR4NWePWSiUZw1+ZLXJm4pFKLhzBlCsRh2RUXacVgeGaF47RrL58+zcP8+RrmMkCQinZ1EL1zAjERqmkH+tLYl1G3bCJw4QUjT0IA0MJfLMX/5MqmHD0nZNiUgtGULG/r7ccXjINWuWbnmqsuFu7sb/4EDNLlcBIEioNs2KUAFGmMxmk6dQm1tRZI+3xBqEkiShBQOox05Ql1nJ26gvuIUAWiKQnj/ftStW5Fk+YuF+NldsbBA4cYN9KdPmaso8Fc62ZJtk7l1C2t0FGdxESHE1xE4hkHh6lX0oSHSpRIewC/LrPf7CSgKNpCamkI/fZr8pUuIZBIcpyaBunahPp1mub+fDyMjGKUSChCsq6Nh717q9u2jbnSU0uAgRrFIwTThyhUCqRS+hgZKLS1fJvDm87SNjZGcnsYUAjcQ8vsJ9/Xh7u1FDgRQN20iks3iDA+zZFmYhQLqzZtsj8WY3L0baY2Sf55ICCKpFHUzM2SEQAJCHg+hY8fQDh5EDgRWDoRC1J88SePRo2geD0XAcBy8b98Sv3ePYDZbbf2rFQjLIphMsmDbaEBQVQkePox26BCSz7e6i4bDrDt+nGYhmBscpFAskheC4Js3bPR4qHphFYEnlcI7P4/jdqNpGu8TCe4oCsXr1z//F2ga3+/cSfTJE0qmSVYIsKzaOZDcbjKyzFIiwfvt21kMBLA07YsetzWNd+3tLLW0sH5igvT8PH9Go/z44kX+E4LGjg7GDYOcy4XlOEgLC//5P/5LCFzxOPLmzWyIx+m6fduu7v0NVGqyTSycKksAAAAASUVORK5CYII=)}
		.unchecked-box {list-style-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAANOgAADMQBiN+4gQAAAAd0SU1FB9gKGQ8qAt8h3m8AAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAA60lEQVRIx+2VsQqDMBRF70sCLg5OLoKgjk7+lJ/hh+STXBwcnRz8ArMEkrxOFktbaC3tULzTg5e8k5vADXDq70VbobXmvu/hvQczg4heHrJfXxQFuq67blZbMc8zpmlCXddIkgTOuZcBUko45zCOI6y1Nz2xFSEEZFmGOI7fGg4A3nsQEZqmuXOu9jallACAtm3fvmutNaIoAjM/dkBECCF89KCbk4eAb+kEnIAT8EsAM0OIz3hSyrssUvss8t5fg+uIrLXPs0gIgWVZYIyBUurQyYdheO4gz3NUVQVjDNZ1PfSjpWmKsixvehfB9GBZ3NndrgAAAABJRU5ErkJggg==)}
		.migrated-box {list-style-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABGdBTUEAALGPC/xhBQAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAANOgAADMQBiN+4gQAAAAd0SU1FB+AKHREFA8vJSnkAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAC1klEQVRIx+2VT0hUURTGf/e958w4Tc3TYowMw1GyEgwr1MqsFmbZIrIWQZsWJUjbdoHQpl3Qps0swnCRECQFYkR/TC1iKkqmfzAKTo2Vf8hoRsfR995tkRMT87RRWkUHHhy495zvnvvu933wP/75EKkkEAjIYDCIaZpIKRFCZN0kfX9xcTGtra2/irVUEolECIfDlJeXo+s6hmFkDaCqKoZhEAqFSCaTv60pqcSyLAoLC/F4PEtqDmCaJkIIKisrMybX0sdUVRWA5ubmPzdNjjI1cpXkZC/O1fV03PXgdDqRUtpPIITAsqxsDz0Z/3CZQv8uqo4N4C8/Tp2/DdM0MiZQlvk41OTkI/LW1SGtCVb5drD3eCc71wcA+VcAHA5vDd8+3UGakxiJV7i9pdQevU5T1R35pJ3MV5QW1pf+0kWBheJ2SWua8EQXZXsu4fVVYEz1sEKvof5EuxjoPvzpcRvrdp9C2gGMx6cpOHBmbImMesds7BZubwMVDTfXDnQ3vQfK7AC8wLfExMX5whyQc3q2OEnjGm5vE76SQxsfBLr77a7CNf+n0r/l6sSMtsBSnurckiIILCobAtVZhpF4gZF4jubaymj4Ch/fd380LE7bAnjc0NPxk2yqpmEuwGxF0ag+0k5uTpzZeBeaazvj0We8fXojainsb2xh2BZgbe0gSIllzSIUh63wfQ6dZ/O2fbjcKlOj58jJ3cVENESw5yErc9nf2MLQ4jwQAkV1Lqiq37/cZ9WaahJjF9AcmxiPDhLs7ePe23oOnmUwg2hSShQle96tKDjA2HAniusgo9FxnvY9Jxw7RWzGYy92QghM00x5g53qp9sHmtB58/o2umOI2NwGolMnMYUHIb7aAyiKwsjICLqu2/qBEIKUUAohMaSHSLyBSMoPTINQ6CX5+fn2AEVFRZSUlBCPx4nFYhl3L4RESjF/GEgX3pSj+Xw+/H7/b3U/AEOZFnp7O5+5AAAAAElFTkSuQmCC)}
		ul {list-style-image: none}
		/* ul rule needed to reset style for sub-bullets */
	</style>
</head>
<body>

<!-- Header -->
<div class='header'>
	[ <span class='insen'>Prev</span> ]

	[ <span class='insen'>Index</span> ]

	[ <span class='insen'>Next</span> ]
</div>

<hr />

<!-- Wiki content -->

<div class='pages'>
	<div class='heading'>
	<h1>1-Introduction <a name='1-Introduction'></a></h1>
	</div>

	<div class='content'>
	<p>
Created Tuesday 14 January 2020
</p>

<h1>Introduction</h1>

<br>

<p>
What is compilation?<br>
<ul>
<li>Translation from one language to another</li>
</ul>
</p>

<p>
<b>Translator:</b> A program that takes as input a program written in one programming language (the <b>source</b> language) and produces an "equivalent" program written in another language (the <b>target</b> language)<br>
<b>Compiler:</b> A translator in which the source language is a high-level language (such as Java or C) and the target language is a low-level language (such as Assembly or machine code)
</p>

<p>
Why compilers?<br>
<ul>
<li>We love programming in high level languages</li>
<li>Computers can only understand it's own machine language</li>
</ul>
</p>

<p>
Each language needs it's own compiler<br>
Each target environment needs a special compiler, so you need different versions of gcc for each machine language.
</p>

<h2>Structure of a Compiler</h2>

<p>
Does two things:<br>
<ul>
<li>analysis</li>
<li>synthesis</li>
</ul>
</p>

<h5>Analysis</h5>

<p>
<b>Front end</b><br>
Breaks up the source program into constituent pieces and imposes a grammatical structure onto them<br>
<ul>
<li>Creates an intermediate representation of the source program</li>
<li>Provides error / warning messages if the program does not fit this grammar (eg syntatically ill formed or semantically unsound)</li>
<li>Collects metadata and stores it in a <u>symbol table</u></li>
</ul>
</p>

<h5>Synthesis</h5>

<p>
<b>Back end</b><br>
<ul>
<li>Constructs the target program from the intermediate representation and the information in the symbol table</li>
</ul>
</p>

<h3>Phases</h3>

<p>
General phases. May be grouped together, and intermediate representations between grouped phases are not necessarily constructed explicitly<br>
Bold denotes phase, normal denotes intermediate repreentation<br>
(start) Character Stream		→ <b>Lexical Analyzer</b><br>
= Token stream	 			→ <b>Syntax Analyzer</b> <br>
= Syntax tree	 				→ <b>Intermediate Code Generator</b><br>
= Intermediate representation 	→ <b>Machine-Independent Code Optimizer</b><br>
= intermediate representation 	→ <b>Code Generator</b> <br>
= target-machine code 		→ <b>Machine-Dependent Code Optimizer</b> <br>
= target machine code<br>
The <b>Symbol Table</b> is used in all phases<br>
The <b>Error Handler</b> is also used in all phases to report info about a bad (ie non-legal) source program
</p>

<p>
The machine-independent code optimizer between the front and back end performs transformations on the intermediate representation so that the back end can generate a better target program. Optional, may have additional phases involved (and at the end).
</p>

<h3>Lexical Analysis</h3>

<br>

<p>
aka <b>scanning</b>
</p>

<p>
<ul>
<li>Reads the stream of characters making up the source program</li>
<li>Groups characters into meaningful sequences called <b>lexemes</b></li>
<li>For each <b>lexeme</b>, analyzer produces an output as a <b>token</b> of the form
<ul>
<li>&lt;token-name, attribute-value&gt;</li>
</ul>
</li>
<li>Passes this to next phase</li>
</ul>
</p>

<p>
<ul>
<li>Token-name
<ul>
<li>abstract symbol that is used during syntax analysis</li>
</ul>
</li>
<li>Attribute-value
<ul>
<li>points to an entry in the symbol table for this token</li>
</ul></li>
</ul>
</p>

<p>
<b>Example:</b>
</p>
<div class="zim-object">
<pre><code class="c">position = initial + rate * 60</code></pre>
</div>

<p>
<ol type="1" start="1">
<li>position is a lexeme, maps to &lt;<b>id</b>, 1&gt;
<ol type="a" start="1">
<li>id is an abstract symbol (identifier)</li>
<li>1 points to the symbol-table entry for position (contains info, eg name, type)</li>
</ol>
</li>
<li>= is a lexeme mapped to the token &lt;=&gt;
<ol type="a" start="1">
<li>needs no attribute-value, so it's ommitted</li>
<li>could use any abstract symbol for assignment</li>
</ol>
</li>
<li>initial is a lexeme, maps to &lt;<b>id</b>, 2&gt;</li>
<li>+ maps to &lt;+&gt;</li>
<li>rate maps to &lt;<b>id</b>, 3&gt;</li>
<li>* maps to &lt;*&gt;</li>
<li>60 maps to &lt;60&gt;
<ol type="a" start="1">
<li>numbers are a bit more complicated, technically would map to something like &lt;<b>number</b>, 4&gt;, where 4 points to the internal representation for 60</li>
</ol></li>
</ol>
</p>

<p>
Blanks are then discarded, so we now have<br>
&lt;<b>id</b>, 1&gt;&lt;=&gt;&lt;<b>id</b>, 2&gt;&lt;+&gt;&lt;<b>id</b>, 3&gt;&lt;*&gt;&lt;60&gt;
</p>

<p>
<b>Example tokens</b><br>
<ul>
<li>reserved keywords (begin, goto, while, if, ...)</li>
<li>user-defined identifiers (x, y, myClass, ...)</li>
<li>constants (25, 2E+5)</li>
<li>special symbols ( , . ( ) ; ...)
<ul>
<li>basically just a reserved keyword, but important to emphasize that the symbol alone is a token that has a meaning associated with it</li>
</ul></li>
</ul>
</p>

<p>
<b>Example 2</b>
</p>
<div class="zim-object">
<pre><code class="c">x := sqrt(y  );
while i&lt;=j do
	whilei = 1022
	1x;
stop</code></pre>
</div>

<p>
Lexical Output:<br>
x		id<br>
:=		key<br>
sqrt		key<br>
(		special symbol<br>
y		id<br>
)		special symbol<br>
;		special symbol<br>
while	key<br>
i		id<br>
&lt;=		key<br>
j		id<br>
do		key<br>
whilei	id<br>
=		ss<br>
1022	constant<br>
1x		lexical error (communicate to error handler, with error type - variable cannot start with number)<br>
;		ss<br>
stop	id
</p>

<p>
Symbol Table:<br>
x		id<br>
y		id<br>
i		id<br>
j		id<br>
whilei 	id<br>
1022	const	due to type conversions that may need to happen, this is stored in the symbol table<br>
stop	id
</p>

<h3>Syntax Analysis</h3>

<br>

<p>
aka <b>parsing</b>
</p>

<p>
<ul>
<li>Uses the first components of the tokens from the lexical analyzer to create a tree-like intermediate representation
<ul>
<li>structure of the program</li>
</ul>
</li>
<li>Builds a <b>syntax tree</b> 
<ul>
<li>interior node = operation</li>
<li>children = arguments of the operation</li>
<li>Tree shows the order in which the operations are to be performed</li>
</ul></li>
</ul>
</p>

<p>
<b>Example:</b><br>
position = initial + rate * 60<br>
<img src="./notes_files/1-Introduction/1.1.SymbolTable.PNG" width="150"><img src="./notes_files/1-Introduction/1.1.SyntaxAnalysis.PNG" width="300">
</p>

<p>
Note that the order of operations is consistent with PEMDAS, eg do multiplication then addition then assignment
</p>

<p>
Can use Context-Free Grammars (Ch 4) to specify the grammar of the programming language
</p>

<h3>Semantic Analysis</h3>

<br>

<p>
Uses syntax tree and symbol table to:<br>
<ul>
<li>check for semantic consistency with language definition</li>
<li>gathers type information and saves it (in either)</li>
<li>performs <b>type checking </b>(matching operands)
<ul>
<li>may need to coerce types (eg int to float)</li>
</ul></li>
</ul>
</p>

<p>
<b>Example</b><br>
<img src="./notes_files/1-Introduction/1.1.SemanticAnalysis.PNG" width="300">
</p>

<h3>Intermediate Code Generation</h3>

<br>

<p>
<ul>
<li>Compiler can construct many different intermediate representations</li>
<li>Syntax trees are a form of intermediate representation</li>
<li>After syntax analysis, many compilers generate an explicit low-level / machine-like representation
<ul>
<li>program for an abstract machine</li>
<li>(should be) easy to produce</li>
<li>(should be) easy to translate to target</li>
<li>One option: <i>three-address code</i>
<ul>
<li>sequence of assembly-like instructions</li>
<li>three operands per instruction</li>
<li>operands act like registers</li>
<li>at most one operator on the right side
<ul>
<li>fix the order of operations this way (eg multiplication first)</li>
</ul>
</li>
<li>compiler must generate temp name to hold the value computed</li>
<li>some instructions have fewer than 3 operands</li>
</ul></li>
</ul></li>
</ul>
Example<br>
<img src="./notes_files/1-Introduction/1.1.IntermediateCodeGenerator.PNG" width="200">
</p>

<h3>Code Optimization</h3>

<br>

<p>
Machine-independent phase<br>
Better can mean:<br>
<ul>
<li>faster</li>
<li>shorter / smaller</li>
<li>lower power consumption</li>
</ul>
</p>

<p>
Example:<br>
<ul>
<li>move inttofloat conversion to compile time (replace with 60.0)</li>
<li>t3 is useless</li>
</ul>
<img src="./notes_files/1-Introduction/1.1.CodeOptimizer.PNG" width="200"><br>
Compilers differ a lot at this phase and can do a lot of stuff (or not)
</p>

<h3>Code Generation</h3>

<br>

<p>
Maps the intermediate representation to a target language.<br>
<ul>
<li>Registers / memory locations are selected for each of the variables used by the program</li>
<li>Then, translated into machine instructions</li>
</ul>
</p>

<p>
Example:<br>
<img src="./notes_files/1-Introduction/1.1.CodeGenerator.PNG" width="200"><br>
F = floating point numbers<br>
R1, R2 = registers<br>
loads contents of id3 into R2, multiplies it by floating point constant 60.0 (# = immediate constant)<br>
moves id2 into R1<br>
Adds R1, R2<br>
R1 is set to the address of id1
</p>

<br>

<p>
Importantly, we've ignored allocation for the identifiers in the source program, which can be different for different languages. Storage-allocation decisions are made either during intermediate code generation or during it.
</p>

<h3>Symbol-Table Management</h3>

<p>
Data structure containing informtion about every variable in the source program<br>
eg: name, type, scope, number / type of arguments, method of passing arguments, type returned (latter for functions)
</p>

<p>
<ul>
<li>Does the boookkeeping job, eg records all user-defined identifiers and their attributes
<ul>
<li>eg: type, scope</li>
</ul></li>
</ul>
</p>

<h3>Error Handler</h3>

<p>
Prints error messages and corrects them when possible
</p>

<h3>Grouping Phases into Passes</h3>

<p>
Logical organization of a compiler<br>
eg: group<br>
<ul>
<li>lexical analysis, syntax analysis, semantic analysis, and intermediate code generation might be grouped together into one pass</li>
<li>Optimization might be an optional pass</li>
<li>back-end pass of code generation</li>
</ul>
</p>

<p>
Can combine different front ends with the same back ends (many languages on one machine) or many back ends with one front end (one language on many machines)
</p>

<h3>Compiler-Construction Tools</h3>

<p>
They exist<br>
<ul>
<li>Parser generators
<ul>
<li>Automatically produce syntax analyzers from a grammar description of a language</li>
</ul>
</li>
<li>Scanner generators
<ul>
<li>Produce lexical analyzers from a regular-expression description of the tokens of a language</li>
</ul>
</li>
<li>Syntax-directed translation engines
<ul>
<li>Produce collections of routines for walking a parse tree and generating intermediate code</li>
</ul>
</li>
<li>Code-generator generators
<ul>
<li>Produce code generator from rules for translating each operation of the intermediate language into the machine language for a target machine</li>
</ul>
</li>
<li>Data-flow analysis engines
<ul>
<li>facilitate the gathering of information about how values are transmitted from one part to another</li>
<li>code optimization</li>
</ul>
</li>
<li>Compiler-construction toolkits
<ul>
<li>provide integrated set of routines for constructing various phases of a compiler</li>
</ul></li>
</ul>
</p>

<h2>Fundamental Concepts</h2>

<p>
1) Analysis vs Synthesis<br>
<ul style='padding-left: 30pt'>
<li>lexical / syntax / semantic analysis</li>
<li>optimization and code generation</li>
</ul>
2) Single-pass vs multi-pass compiler<br>
<ul style='padding-left: 30pt'>
<li>single-pass = time-effecient</li>
<li>multi-pass = space-effecient</li>
<li>multi-pass avoids keeping large intermediate objects (eg syntax tree) in memory (== good)</li>
</ul>
3) Front-end vs back-end<br>
<ul style='padding-left: 30pt'>
<li>front end = source language-aware (depends on source language BUT NOT target machine)</li>
<li>back end = target language-aware (depends on target machine) </li>
<li>!! can mix and match! eg many back-ends for one front-end C compiler, or many front-ends for one back-end x86 compiler</li>
</ul>
</p>


	</div>

	<br />

	<div class='page-footer'>

			<b>Attachments:</b>
			<table>

			<tr><td><a href='./notes_files/1-Introduction/1.1.CodeGenerator.PNG'>1.1.CodeGenerator.PNG</a></td><td>&nbsp;</td><td>10.1kb</td></tr>


			<tr><td><a href='./notes_files/1-Introduction/1.1.CodeOptimizer.PNG'>1.1.CodeOptimizer.PNG</a></td><td>&nbsp;</td><td>3.82kb</td></tr>


			<tr><td><a href='./notes_files/1-Introduction/1.1.IntermediateCodeGenerator.PNG'>1.1.IntermediateCodeGenerator.PNG</a></td><td>&nbsp;</td><td>7.34kb</td></tr>


			<tr><td><a href='./notes_files/1-Introduction/1.1.SemanticAnalysis.PNG'>1.1.SemanticAnalysis.PNG</a></td><td>&nbsp;</td><td>9.09kb</td></tr>


			<tr><td><a href='./notes_files/1-Introduction/1.1.SymbolTable.PNG'>1.1.SymbolTable.PNG</a></td><td>&nbsp;</td><td>9.12kb</td></tr>


			<tr><td><a href='./notes_files/1-Introduction/1.1.SyntaxAnalysis.PNG'>1.1.SyntaxAnalysis.PNG</a></td><td>&nbsp;</td><td>7.64kb</td></tr>

			</table>
	</div>

	<hr />

	<div class='heading'>
	<h1>1-Lexical Analysis <a name='1-Introduction:1-Lexical Analysis'></a></h1>
	</div>

	<div class='content'>
	<p>
Created Tuesday 21 January 2020
</p>

<p>
<b>Scanner</b><br>
<ul>
<li>Reads in tokens</li>
<li>stores them in the symbol table</li>
</ul>
</p>

	</div>

	<br />

	<div class='page-footer'>

	</div>

	<hr />

	<div class='heading'>
	<h1>2-Syntax Analysis <a name='1-Introduction:2-Syntax Analysis'></a></h1>
	</div>

	<div class='content'>
	<p>
Created Tuesday 21 January 
</p>

<p>
<b>Syntax Analysis = Parser</b><br>
<ul>
<li>Operates over symbols</li>
<li>Tokens generated by the scanner</li>
<li>Builds a parse tree of some program</li>
</ul>
</p>

<p>
Do this via Context Free Languages (CFL), which we will then evaulate via a PDA<br>
<ul>
<li>Useful because a CFL can set the rules for ANY programming language</li>
</ul>
</p>

<p>
<b>Example:</b><br>
Assumptions: no decimals, id starts with a single, case-insensitive letter
</p>

<p>
&lt;asmt&gt; 	→  &lt;id&gt; := &lt;expr&gt;<br>
&lt;expr&gt; 	→ &lt;expr&gt; + &lt;expr&gt; | &lt;expr&gt; * &lt;expr&gt; | (&lt;expr&gt;) | &lt;id&gt; | &lt;const&gt;<br>
&lt;id&gt; 	→ &lt;letter&gt; | &lt;id&gt;&lt;letter&gt; | &lt;id&gt;&lt;digit&gt;	//must start with letter<br>
&lt;letter&gt; 	→ a | b | c | d | ... | z<br>
&lt;digit&gt; 	→ 0 | ... | 9<br>
&lt;const&gt;	→ &lt;digit&gt; | &lt;const&gt;&lt;digit&gt;
</p>

<p>
Nontermials:	6   (something that appears in the left-hand side of the rule)<br>
Terminals:	42 (everything but the nontermials, :=+*( )abc...0...9 )<br>
Rules:		47<br>
Start symbol	&lt;asmt&gt;
</p>

<p>
<b>Parse Tree:</b>
</p>

<p>
<div style='padding-left: 90pt'>
&lt;asmt&gt;<br>
/	|  |   		\
</div>
<div style='padding-left: 60pt'>
&lt;id&gt;	:  =		&lt;expr&gt;<br>
/  |				/	|	\
</div>
<div style='padding-left: 30pt'>
&lt;id&gt;  &lt;digit&gt;       &lt;expr&gt;   +	&lt;expr&gt;<br>
   |		|		  |			/	|	\<br>
&lt;letter&gt;   2		&lt;id&gt;     &lt;expr&gt;     *	&lt;expr&gt;<br>
   |				  |||		  |||			  |||<br>
   x				y57		256			z4y9
</div>
</p>

<p>
Note: ||| is basically just "figure it out"
</p>

<p>
A lot of this (going from &lt;id&gt; down to the specifics, is actually done by the scanner!!<br>
<ul>
<li>We deal with tokens (symbols?), not really terminals</li>
</ul>
</p>

<p>
With this, the parse tree becomes:
</p>

<p>
<div style='padding-left: 90pt'>
&lt;asmt&gt;<br>
/	|  |   		\
</div>
<div style='padding-left: 60pt'>
&lt;id&gt;	:  =		&lt;expr&gt;<br>
   |				/	|	\<br>
&lt;.&gt;		        &lt;expr&gt;   +	&lt;expr&gt;
</div>
<div style='padding-left: 150pt'>
  |			/	|	\<br>
&lt;id&gt;     &lt;expr&gt;     *	&lt;expr&gt;
</div>
<div style='padding-left: 180pt'>
|			|			|
</div>
<div style='padding-left: 150pt'>
  &lt;.&gt;	&lt;const&gt;		     &lt;id&gt;
</div>
<div style='padding-left: 270pt'>
  |			|
</div>
<div style='padding-left: 240pt'>
&lt;.&gt;			&lt;.&gt;
</div>
</p>

<p>
Where &lt;.&gt; just means a pointer to the symbol table<br>
SymTable:<br>
256		&lt;const&gt;<br>
x2		&lt;id&gt;<br>
y57		&lt;id&gt;<br>
zry9		&lt;id&gt;
</p>


	</div>

	<br />

	<div class='page-footer'>
		<b>Backlinks:</b>

		<a href='#1-Introduction:3-Semantic Analysis'>1-Introduction:3-Semantic Analysis</a>

		<br /><br />

	</div>

	<hr />

	<div class='heading'>
	<h1>3-Semantic Analysis <a name='1-Introduction:3-Semantic Analysis'></a></h1>
	</div>

	<div class='content'>
	<p>
Created Tuesday 21 January 2020
</p>

<p>
Recieves parse tree from <a href="#1-Introduction:2-Syntax Analysis" title="2-Syntax Analysis" class="page">2-Syntax Analysis</a> (which contains the full information about the physical structure of the program)
</p>

<p>
Semantic Analysis = analyses the meaning (function) of the source code and performs type checking / conversion<br>
<ul>
<li>Figure out the meaning of the program</li>
<li>Makes code generation possible</li>
<li>Function</li>
</ul>
</p>


	</div>

	<br />

	<div class='page-footer'>

	</div>

	<hr />

	<div class='heading'>
	<h1>4-Intermediate Code Generator <a name='1-Introduction:4-Intermediate Code Generator'></a></h1>
	</div>

	<div class='content'>
	<p>
Created Thursday 23 January 2020
</p>

<p>
<ul>
<li>Produces a sequence of intermediate symbolic codes
<ul>
<li>typically 3-address codes involving at most 3 operands</li>
<li>idea: generte <b>short</b> sequences (lines)</li>
<li>eg: A := B x C</li>
</ul></li>
</ul>
<img src="./notes_files/1-Introduction/4-Intermediate_Code_Generator/CS4323-compilers - 2.png" width="400"><br>
There will be a fixed number of distinct <b>small</b> tries like this<br>
Generate code from the tree
</p>

<p>
Eg:<br>
R1 := C * 23<br>
R2 := B + R1<br>
A   := R2
</p>

	</div>

	<br />

	<div class='page-footer'>

			<b>Attachments:</b>
			<table>

			<tr><td><a href='./notes_files/1-Introduction/4-Intermediate_Code_Generator/CS4323-compilers - 2.png'>CS4323-compilers - 2.png</a></td><td>&nbsp;</td><td>22.6kb</td></tr>

			</table>
	</div>

	<hr />

	<div class='heading'>
	<h1>5-Code Optimization <a name='1-Introduction:5-Code Optimization'></a></h1>
	</div>

	<div class='content'>
	<p>
Created Thursday 23 January 2020
</p>

<p>
Transforms the intermediate code into more time / space effecient codes<br>
<ul>
<li>Global optimization 
<ul>
<li>Performs optimization considering it's effect over the entire source program</li>
<li>Uses data / control flow analysis evaluate effect</li>
</ul>
</li>
<li>Local optimization
<ul>
<li>Considers only small portions of the source program to improve code</li>
</ul></li>
</ul>
</p>

<p>
Example: Peephole optimization<br>
<ul>
<li>Use a window of fixed size to optimize (eg optimize inside this frame)</li>
<li>Tile windows throught program</li>
</ul>
</p>

<p>
Example: Go from <br>
R1 := C * 23<br>
R2 := B + R1<br>
A   := R2
</p>

<p>
To:<br>
R1 := C * 23<br>
A   := B + R1
</p>

<p>
Note that this is only useful if R2 is not elsewhere.
</p>

	</div>

	<br />

	<div class='page-footer'>

	</div>

	<hr />

	<div class='heading'>
	<h1>6-Code Generator <a name='1-Introduction:6-Code Generator'></a></h1>
	</div>

	<div class='content'>
	<p>
Created Thursday 23 January 2020
</p>

<p>
Produces target code in the form of assembly code or relocatable machine code
</p>

<p>
Example:<br>
R1 := C * 23<br>
A  := B + R1
</p>

<p>
(A) Translation:<br>
LOAD C<br>
MULT 23<br>
COPY R1<br>
LOAD B<br>
ADD R1<br>
COPY A
</p>

<p>
This can also be optimized:<br>
LOAD C<br>
MULT 23<br>
ADD B<br>
COPY A
</p>

<p>
(presuming R1 isn't used later)
</p>

<p>
With Symbol Table:
</p>

	</div>

	<br />

	<div class='page-footer'>

	</div>

	<hr />

	<div class='heading'>
	<h1>Compiler-Generator <a name='1-Introduction:Compiler-Generator'></a></h1>
	</div>

	<div class='content'>
	<p>
Created Thursday 23 January 2020
</p>

<p>
Aka <b>Compiler Compiler</b>
</p>

<p>
<ul>
<li>A program that take the descriptioin of the main features of the source language and produces a component of the compiler</li>
</ul>
</p>

	</div>

	<br />

	<div class='page-footer'>

	</div>

	<hr />

	<div class='heading'>
	<h1>4-Syntax Analysis <a name='4-Syntax Analysis'></a></h1>
	</div>

	<div class='content'>
	<p>
Created Thursday 30 January 2020
</p>

<p>
Two types: top down, bottom up
</p>

<h1>Top Down Parsing</h1>

<br>

<p>
Syntax analyzer does the majority syntax checking
</p>

<p>
Example:<br>
L = { a<sup>n</sup>b<sup>n</sup> | n &gt;= 0 }<br>
has the pattern aa...bb<br>
It is context-free but not regular, so it cannot be recognized by a DFA
</p>

<p>
<ul>
<li>The language of all nested parentheses (or begin-ends) is not regular and therefore not context free</li>
<li>Therefore, this pattern cannot be checked y the scanner and can be only done by the parser</li>
</ul>
</p>

<p>
Similarly, some language features cannot be described by context-free rules, so they cannot be checked by the parser, but can be done by the next level of the compiler (semantic analyzer)
</p>

<p>
Example:<br>
L = { wzw | w ∈ {a,b}*, ie the language feature that identifies must be declared before use is not context free but is context-sensitive }<br>
<ul>
<li>checked by semantic analyzer</li>
</ul>
</p>

<h5>Parse Trees and Derivations</h5>

<p>
Example:<br>
E -&gt; E + E | E * E | &lt;id&gt;<br>
Derivations:<br>
E 	=&gt; E + E =&gt; E * E + <br>
<div style='padding-left: 30pt'>
=&gt; &lt;id&gt; * E + E<br>
=&gt; &lt;id&gt; * &lt;id&gt; + E<br>
=&gt; &lt;id&gt; * &lt;id&gt; + &lt;id&gt;
</div>
</p>

<p>
Begin = start symbol<br>
Intermediate = sentential forms<br>
Last form = sentence (only terminals)<br>
Sequence = derivation
</p>

<p>
Can subscript the arrows to indicate that it is a left-most derivation<br>
=&gt;<sub>lm</sub>
</p>

<p>
<b>Given a derivation, there exist exactly one tree</b><br>
<b>Given a tree, there are many possible derivations that generate that tree</b><br>
<div style='padding-left: 30pt'>
<b>However, only one left-most derivation exists</b>
</div>
</p>

<br>

<p>
Top down = left most<br>
Bottom up = right most
</p>

<h5>Ambiguity</h5>

<p>
Def:<br>
A CFG is ambiguous if there are multple parse trees for some terminal string.
</p>

<p>
CFG ambiguity is undecidable
</p>

<p>
Strategy:<br>
For specific CFG, write everything you can as a right-linear grammar, then it's easy to analyze the few rules that can't be expressed this way.<br>
If it is right-linear, it's not ambiguous (??  - not sure about this)
</p>

<p>
Generally, you can transform most things from an ambiguous set of rules to a non-ambiguous set of rules
</p>

<h5>Disambiguation</h5>

<br>

<p>
EG: * &gt; + (multiplication has a higher priority than multiplication)<br>
E -&gt; E + T | T<br>
T -&gt; T * F | F<br>
F -&gt; &lt;id&gt;
</p>

<p>
Now, it's non-ambiguous
</p>

<p>
keywords: begin, if, int<br>
identifiers: seq of english chars<br>
constants: seq of digits (possibly including decimal)<br>
special symbols: : , =
</p>

<h1>Deterministic Parsing</h1>

<p>
There are two well-known "Universal Context-Free" deterministic parsing methods<br>
<ol type="1" start="1">
<li>CYK (Cocke-Younger-Kasami) or Earley's algoritm
<ol type="a" start="1">
<li>Can handle any CFL in O(n^3) time</li>
</ol>
</li>
<li>Top-Down (LL) and Bottom-Up (LR) parsing algorithms
<ol type="a" start="1">
<li>can handle large subclasses of CFLs in O(n) time</li>
</ol></li>
</ol>
</p>

<h2>CYK</h2>

<p>
Given a CFG G = (N, Σ, P, S) in CNF, and an input string w ∈ Σ* , decide if w ∈ L(G)
</p>

<p>
Note: in CNF (Chomsky Normal Form), each rule either maps to a single terminal or two non-terminals, which means that the parse tree is always binary (!)
</p>

<p>
Work bottom-up - every terminal symbol MUST come from a terminal symbol, so consider all possible ways to generate a symbol, eg:<br>
A -&gt; c<br>
B -&gt; c<br>
and combine them in all possible ways<br>
<img src="./notes_files/4-Syntax_Analysis/CYK.png" width="500"><br>
<img src="./notes_files/4-Syntax_Analysis/CYK-example.png" width="500"><br>
Time: O(n<sup>2 </sup>* n * |N|<sup>2</sup>) = O(n<sup>3</sup>)<br>
|N| = length of N rules?
</p>

<h2>Top-Down Parsing</h2>

<p>
Given a CFG G and a string W, construct a parse tree for w in G top-down, ie start with the start symbol of G and EXPAND nonterminals in order to generate w.
</p>

<p>
EXPAND:<br>
Given any non-terminal A, choose one of it's productions to expand and follow it.<br>
How do we determine which one to expand?
</p>

<p>
 <img src="./notes_files/4-Syntax_Analysis/top-down-parsing.png" width="500">
</p>

<p>
DPDA
</p>

<p>
<img src="./notes_files/4-Syntax_Analysis/DPDA-ex.png" width="500">
</p>

<p>
NPDA
</p>

<p>
<img src="./notes_files/4-Syntax_Analysis/NPDA-ex.png" width="500">
</p>

	</div>

	<br />

	<div class='page-footer'>

			<b>Attachments:</b>
			<table>

			<tr><td><a href='./notes_files/4-Syntax_Analysis/CYK-example.png'>CYK-example.png</a></td><td>&nbsp;</td><td>159kb</td></tr>


			<tr><td><a href='./notes_files/4-Syntax_Analysis/CYK.png'>CYK.png</a></td><td>&nbsp;</td><td>151kb</td></tr>


			<tr><td><a href='./notes_files/4-Syntax_Analysis/DPDA-ex.png'>DPDA-ex.png</a></td><td>&nbsp;</td><td>110kb</td></tr>


			<tr><td><a href='./notes_files/4-Syntax_Analysis/NPDA-ex.png'>NPDA-ex.png</a></td><td>&nbsp;</td><td>129kb</td></tr>


			<tr><td><a href='./notes_files/4-Syntax_Analysis/top-down-parsing.png'>top-down-parsing.png</a></td><td>&nbsp;</td><td>172kb</td></tr>

			</table>
	</div>

	<hr />

	<div class='heading'>
	<h1>Home <a name='Home'></a></h1>
	</div>

	<div class='content'>
	<p>
Created Tuesday 14 January 2020
</p>

<p>
Lexical Analysis = finite automata series<br>
<div style='padding-left: 30pt'>
- To construct, construct finite automata
</div>
</p>

<p>
Spend ~2.5 weeks to cover fundamental compiling concepts (ch 1, 2)<br>
Then, we'll do Ch 3 (very long in book, but we will be skipping DFAs because we've taken ToC)<br>
- Then, we'll know how to construct a lexical analyzer<br>
*** First programming assignment
</p>

<br>

<p>
We'll be learning the theory at a very high level, and constructing a working compiler
</p>

<br>


	</div>

	<br />

	<div class='page-footer'>

	</div>

	

</div>

</body>
</html>
